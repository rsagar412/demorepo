
Thanks for sharing the screenshots and code. Based on the investigation:

‚úÖ Problem Identified:

You're not getting data from the database, but the CSV fallback is working, which means:

Your DB connection and Spark setup are correct.

The SQL query likely does not match any records due to a mismatch in timestamp format.


üìå Root Cause:

Your query filters CREATED_DATE using epoch millis (long values) via:

WHERE CREATED_DATE BETWEEN %d AND %d

But in Oracle:

CREATED_DATE is a DATE or TIMESTAMP type.

Epoch millis like 1726138792000 won‚Äôt match unless explicitly cast.



---

‚úÖ Fix: Convert millis to Oracle TIMESTAMP

Update the JdbcQuery.java to generate SQL like this:

SELECT * FROM %s
WHERE CREATED_DATE BETWEEN TO_TIMESTAMP(%d / 1000) AND TO_TIMESTAMP(%d / 1000)

But Oracle doesn‚Äôt directly allow %d / 1000 ‚Äî you must calculate it in Java.


---

üîß Suggested Code Fix

JdbcQuery.java

public static final String SELECT_BY_CREATED_DATE_TEMPLATE = """
    SELECT * FROM %s
    WHERE CREATED_DATE BETWEEN TO_TIMESTAMP('%s', 'YYYY-MM-DD HH24:MI:SS.FF')
    AND TO_TIMESTAMP('%s', 'YYYY-MM-DD HH24:MI:SS.FF')
    """;

public static String getQueryByCreatedDate(String table, long currentMillis) {
    Instant now = Instant.ofEpochMilli(currentMillis);
    Instant oneDayBefore = now.minus(Duration.ofDays(1));
    
    String nowFormatted = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss.SSS")
        .withZone(ZoneId.systemDefault()).format(now);
    String oneDayBeforeFormatted = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss.SSS")
        .withZone(ZoneId.systemDefault()).format(oneDayBefore);

    return String.format(SELECT_BY_CREATED_DATE_TEMPLATE, table, oneDayBeforeFormatted, nowFormatted);
}


---

‚úÖ Usage in SparkService.java

Replace:

String query = JdbcQuery.getYesterdayQuery("MERCHANT_ORDER_PAYMENTS", currentTimeMillis());

with:

String query = JdbcQuery.getQueryByCreatedDate("MERCHANT_ORDER_PAYMENTS", currentTimeMillis());


---

‚úÖ Final Thoughts

You must always match Oracle DATE/TIMESTAMP with TO_DATE() or TO_TIMESTAMP(), not numeric millis.

You‚Äôre reading CSV because the DB result is empty due to this mismatch.


Let me know if you want to parameterize this for custom time ranges or cron-based scheduling.


Absolutely! Based on your earlier screenshot (getYesterdayQuery) and your request, here‚Äôs a simple version of a method getQueryByCreatedDate that builds a query using a specific createdDate timestamp in milliseconds.


---

‚úÖ Goal

Generate a SQL like:

SELECT * FROM <table> WHERE CREATED_DATE = <createdDate>


---

üß© Code Implementation

@UtilityClass
public class JdbcQuery {

    public static final String SELECT_BY_CREATED_DATE_TEMPLATE = """
        SELECT * FROM %s
        WHERE CREATED_DATE = %d
        """;

    public static String getQueryByCreatedDate(String table, long createdDateMillis) {
        return String.format(SELECT_BY_CREATED_DATE_TEMPLATE, table, createdDateMillis);
    }
}


---

üìù Example Usage

String query = JdbcQuery.getQueryByCreatedDate("MERCHANT_ORDER_PAYMENTS", 1726138792000L);

This would produce:

SELECT * FROM MERCHANT_ORDER_PAYMENTS
WHERE CREATED_DATE = 1726138792000


---

Let me know if you want:

Range-based query (e.g. BETWEEN instead of =),

Support for readable timestamps (yyyy-MM-dd HH:mm:ss),

Or to combine this with other filters.



